package gov.ornl.stucco.rt.bolt

import backtype.storm.task.{OutputCollector, TopologyContext}
import backtype.storm.topology.base.BaseRichBolt
import backtype.storm.topology.OutputFieldsDeclarer
import backtype.storm.tuple.{Fields, Tuple, Values}

import java.util.{Map => JMap}
import java.security.MessageDigest

import grizzled.slf4j.Logging

/** A bolt that generates and appends a universally unique identifier (UUID)
  * to input tuples.
  *
  * The UUID is generated by computing a SHA-512 hash of the input string
  * so that the UUID is deterministic based on the input. This ensures that
  * even if a tuple is processed more than once, there won't be duplicate or
  * orphaned entries in persistent storage downstream.
  */
class UUIDBolt extends BaseRichBolt with Logging {

  private var collector: OutputCollector = _

  /** Computes an SHA-512 hash of a string.
    *
    * @param data String to compute the hash of.
    *
    * @return A string containing the hexadecimal representation of the hash.
    */
  def hash(data: String): String = {
    // use Java's built in digest mechanism
    val bytes = MessageDigest getInstance "SHA-512" digest data.getBytes
    // convert bytes to hex string
    ("" /: bytes) { (str, byte) => str + f"$byte%02x" }
    }

  /** Process a tuple by computing and appending its UUID.
    *
    * @return `Values` containing the UUID and JSON string.
    */
  def process(json: String): Values = {
    new Values(hash(json), json)
  }
  
  override def prepare(config: JMap[_, _],
      context: TopologyContext,
      collector: OutputCollector) {
    info("preparing for operation")
    this.collector = collector
  }

  override def execute(tuple: Tuple) {
    debug(s"executing tuple: $tuple")
    val json = tuple getStringByField "json"
    collector.emit(tuple, process(json))
    collector.ack(tuple)
  }

  override def declareOutputFields(declarer: OutputFieldsDeclarer) {
    declarer.declare(new Fields("uuid", "json"))
  }
}
